#!/usr/bin/expect

#set fhc [open "characteristics.lst" r]
#set fhr [open "charas.read.lst" r]
set deviceExcludeFilename "device.exclude.lst"

set ring_uuid_set "0000face"
set discover_attempts 3
set connect_attempts 3
set ringcrypto "../test_crypto"

set ring_name [lindex $argv 0]
if { $ring_name == "" || $ring_name == "\n" || $ring_name == "\r"} {
    puts "error: ring_name $ring_name\nusage: expect pairing.expect.script <ring_name> <ssid>  <password> <secret_key>\nexit 66"
    exit 66
} else {
    puts "ring_name: $ring_name"
}

# set WiFi credentials
set ssid [lindex $argv 1]
if { $ssid == "" || $ssid == "\n" || $ssid == "\r"} {
    set ssid "ssid_not_set_with_arg"
    puts "warning: ssid $ssid\nusage: expect pairing.expect.script <ring_name> <ssid> <password> <secret_key>"
} else {
    puts "ssid: $ssid"
}

set pass [lindex $argv 2]
if { $pass == "" || $pass == "\n" || $pass == "\r"} {
    set pass "pass_not_set_with_arg"
    puts "warning: pass $pass\nusage: expect pairing.expect.script <ring_name> <ssid> <password> <secret_key>"
} else {
    puts "pass: $pass"
}
set network_credentials "{\"ssid\":\"$ssid\",\"pass\":\"$pass\"}"

# set secret_key
set secretkey [lindex $argv 3]
if { $secretkey == "" || $secretkey == "\n" || $secretkey == "\r"} {
    set secret_key "secret_key_not_set_with_arg"
    puts "warning: secret_key $secret_key\nusage: expect pairing.expect.script <ring_name> <ssid> <password> <secret_key>"
} else {
    set secret_key $secretkey
    puts "secret_key: $secret_key"
}
#puts "$secret_key\n"

#set provision_xml "<network><mode>client</mode><client><wireless><password>$pass</password><ssid>$ssid</ssid><channel>1</channel><security>wpa-personal</security></wireless><object_id>223192</object_id><secret_key>$secret_key</secret_key><ip><subnectmask></subnetmask><ip_type>dhcp</ip_type><ip_addr></ip_addr><gateway></gateway><dns_addr></dns_addr></ip></client><app_mode>usr</app_mode><ethernet>0</ethernet></network>"
set provision_xml "<network><mode>client</mode></network>"

# Set timeout
set timeout 20

# set secret_key
set debug [lindex $argv 4]
puts "debug: $debug\n"
if { $debug != "debug" } {
    log_user 0
}

# run bluetoothctl
spawn bluetoothctl
set blueID $spawn_id
expect "Agent registered"

# the following line is for multiple BT adapters on the same machine - update as needed
# if only single BT adapter then the next command will be ignored (failed)
send "select 5C:F3:70:84:E8:8B\r"
#-----------------------------------------------------------
#------ scan LE and find device by $ring_name --------------
#-----------------------------------------------------------
set mac ""
set attempts $discover_attempts
for {set x 0} {$x<$attempts} {incr x} {
    puts "\n\nscan.$x\n\n"

    # check devices
    send "devices\r"
    send "list\r"
    expect "Controller"

    #puts "in: $expect_out(0,string)"
    #puts "out: $foundring\n\n"

    # check the whole list of discovered devices line by line to select by name and exclude ignored
    set buf [split $expect_out(buffer) " "]
    for {set idx 0} {$idx<1000} {incr idx} {
       set e [lindex $buf $idx]
       #puts "$idx : $e"
       if { $e == "" } {
	   break
       } else {
	    if {[string match "*$ring_name*" $e] && $idx > 0} {
		#puts "$idx: found $e"
		incr idx -1
		set e [lindex $buf $idx]
		    puts "$idx: found $ring_name = $e, checking for ignore"

		    set bIgnore 0
		    #----------------------------------------------------
		    # check ignore list from file device.exclude.lst
		    #----------------------------------------------------
		    if {[file exists $deviceExcludeFilename]} {
			set inFileId [open $deviceExcludeFilename "r"]
			foreach sline [read $inFileId] {
			    set sbuf [split $sline "/"]
			    set smac [lindex $sbuf 0]
			    puts "ignore list: $smac"
			    if { $smac == $e } {
				set bIgnore 1
				break
			    }
			}
			close $inFileId
		    }
		    #----------------------------------------------------
		    if { $bIgnore == 0 } {
			set timeout 2
			#----------------------------------------------------
			# check device info to identify LE vs. BT
			#----------------------------------------------------
			send "info $e\r"
			expect {
			    "0000face-0000-1000-8000"	{
				puts "$e is LE device by UUID"
				set mac $e
				break
			    }
			    "Appearance:"	{
				puts "$e is LE device by Appearance"
				set mac $e
				break
			    }
			    "Modalias:	{
				puts "oops... $e has no UUID or Appearance? - probably BT device"
			     }
			}
			set timeout 20
			puts "$ring_name=$e will ber ignored, continue..."
			#----------------------------------------------------
			# save device mac to ignore
			#----------------------------------------------------
			puts "adding $mac to device.exclude.lst"
			set outFileId [open $deviceExcludeFilename "a"]
			puts $outFileId "$e/*$ring_name*/"
			close $outFileId
		    }
		    incr idx 1
	    }
       }
    }

    set timeout 20
    if { $mac != "" }	{
	puts "found mac \"$mac\"\n"
	break
    }

   if { $mac != "" } {
      break
   }

   # set LE scan filter?
   #send "set-scan-filter-transport le\r"
   #expect "SetDiscoveryFilter success"

   # start scan
   send "scan on\r"
   expect -nocase $ring_name

   # stop scan
   send "scan off\r"
   expect "Discovery stopped"

   if { $mac != "" } {
      break
   }
}

if { $mac == "" } {
    puts "failed to discover $ring_name, exiting 13\n"
    send "quit\n"
    exit 13
}

#-----------------------------------------------------------
#------ connection section ---------------------------------
#-----------------------------------------------------------
set device_connected 0
set attempts $connect_attempts
set timeout 20
while { $attempts>0 } {
    #---- connection --------
    send "connect $mac\r"
    expect {
	"Failed to connect:"	{
	    puts "\n\nfailed to connect\n\n"
	}
	"not available" 		{
	    puts "\n\ndevice went offline or removed from the list, abort.\n\n"
	    # break from the attempts loop
	    break
	}
	"ServicesResolved: yes"	{
	    set device_connected 1
	    # break from the attempts loop
	    break
	 }
	 timeout    		{
	    puts "\n\nconnect timeout...\n\n"
	}
    }
    # send "disconnect $mac\r"
    # expect "disconnected"
    incr attempts -1
}

if { $device_connected == 0 } {
    puts "failed to connect $ring_name, exiting 10\n"
    send "quit\n"
    exit 10
}

#-----------------------------------------------------------
#------ pairing prepare ------------------------------------
#-----------------------------------------------------------
# prepare lists of uuid of characteristics
set uuidListFilename "expect.uuid.lst"
set charas_count 0
send "list-attributes\r"
send "list\r"
expect "Controller"

# store uuid:url in the file
set outFileId [open $uuidListFilename "w"]

set buf [split $expect_out(buffer) "\n"]
for {set idx 0} {$idx<1000} {incr idx} {
    set e [lindex $buf $idx]
    #puts "$idx : $e"
    if { $e == "" } {
       break
    } else {
	if {[string match "*$ring_uuid_set*" $e] && $idx > 0} {
	    incr idx -1
	    set url [lindex $buf $idx]
	    incr idx 1
	    regsub -all {\s} $e {} fe
	    regsub -all {\s} $url {} furl
	    puts $outFileId "$fe:$furl"
	    incr charas_count 1
	    #puts "$charas_count.$fe:$furl"
	}
    }
}
#Close file descriptor to ensure data are flush to file
close $outFileId

if { $charas_count == 0 } {
    puts "failed to colect characteristics from $ring_name, exiting 9\n"
    send "disconnect $mac\r"
    send "quit\n"
    exit 9
} else {
    puts "\n$charas_count characteristics parsed; starting pairing\n"
}

#-----------------------------------------------------------
#------ actual pairing scenario ----------------------------
#-----------------------------------------------------------
set timeout 20
set fhp [open "crypto.pairing.cmd.lst" r]
set data [read $fhp]
foreach line $data {
    #puts "$line"

    set buf [split $line ":"]
    set command [lindex $buf 0]
    set uuid    [lindex $buf 1]
    set name    [lindex $buf 2]
    set payload [lindex $buf 3]

    puts "command     = $command"
    puts "uuid        = $uuid   "
    puts "name        = $name   "
    puts "payload     = $payload\n"

    # find url by uuis using lookup file
    # for some reasong select uuid doesn't make affect with bluetoothctl
    set url ""
    set inFileId [open $uuidListFilename "r"]
    foreach sline [read $inFileId] {
    set sbuf [split $sline ":"]
    set suuid [lindex $sbuf 0]
	if { $suuid == $uuid } {
	    set url [lindex $sbuf 1]
	    break
	}
    }
    close $inFileId

    if { $url == "" } {
       puts "not found matching url, skip...\n"
       continue
    } elseif { $command == "W"}    {
						    #    __        ______  ___ _____ _____
						    #    \ \      / /  _ \|_ _|_   _| ____|
						    #     \ \ /\ / /| |_) || |  | | |  _|
						    #      \ V  V / |  _ < | |  | | | |___
						    #       \_/\_/  |_| \_\___| |_| |_____|
	send "select-attribute $url\r"

	if { $payload == "secret_key" } {
	    puts "putting secret key"
	    set payload $secret_key
	} elseif  { $payload == "public_key" } {
	    #------------------------------------------ request from crypto public_key and send it to device
	    puts "\r"
	    spawn $ringcrypto -gpk
	    expect ":gpk"
	    set buf [split $expect_out(buffer) ":"]
	    set public_key [lindex $buf 1]

	    # resetore bluetoothctl ID
	    set spawn_id $blueID
	    set payload $public_key

	} elseif { $payload == "network_credentials" } {
	    puts "## putting credential"
	    set payload $network_credentials

	} elseif { $payload == "provision_xml" } {
	    puts "## sending provisioning information in xml"
	    set payload $provision_xml
	    if { $debug != "debug" } {
		log_user 1
	    }
	}
	# only SECRET KEY is used unencrypted
	if { $name == "SET_PUBLIC_KEY" } {
	    puts "sending public_key"
	} else {
	    # encrypt payload
	    spawn $ringcrypto -enc $payload
	    expect ":enc"
	    set buf [split $expect_out(buffer) ":"]
	    puts "actual payload = $payload"
	    set payload [lindex $buf 2]
	    puts "encrypted payload = $payload"

	    # always restore spawn id after using $ringcrypto
	    set spawn_id $blueID
	}

	# convert payload to ASCII bytes - USE ONLY WITH TEXTUAL NOT ENCRYPTED PAYLOADS except public keys
	# 	set converted ""
	# 	foreach char [split $payload ""] {
	# 	    lappend converted [scan $char %c]
	# 	}
	# 	set payload $converted

	send "write $payload\r"
	expect "Attempting to write"

    } elseif { $command == "R"}    {
						    #    ____  _____    _    ____
						    #   |  _ \| ____|  / \  |  _ \
						    #   | |_) |  _|   / _ \ | | | |
						    #   |  _ <| |___ / ___ \| |_| |
						    #   |_| \_\_____/_/   \_\____/
	send "select-attribute $url\r"
	send "read\r"

	expect "Value:"
	send "attribute-info\r"
	expect "Value:"
	expect  $ring_name
	puts "\r"

	if { $name == "GET_PUBLIC_PAYLOAD" } { #----------------- PUBLIC PAYLOAD ------------------------------

	    #parse the value and pass it to test_crypto for update
	    puts "==============================\n"
	    set buf [split $expect_out(buffer) "\n"]
	    set pld ""
	    set public_payload "public_payload.log"
	    set outFileId [open $public_payload "w"]
	    for {set idx 0} {$idx<100} {incr idx} {
		set pubpl [lindex $buf $idx]
		if {[string match "*list*" $pubpl]} {
		    break
		}
		if {[string match "*$ring_name*" $pubpl]} {
		    break
		}
		append pld '\n $pubpl
		puts $outFileId "$pubpl"
	    }
	    close $outFileId

	    spawn $ringcrypto -ppf public_payload.log
	    expect {
		":ppp" {
		    puts "Public Payload processed OK"
		}
		"Error" {
		    puts "Public Payload Error. ------- Abort-------- \n"
		    set spawn_id $blueID
		    send "disconnect\r"
		    expect "Connected: no"
		    send "quit\r"
		    exit -18
		}
	    }
	    # always restore spawn id after using $ringcrypto
	    set spawn_id $blueID

	} else {
	    # all other attributes are encrypted

	    #decode value
	    puts "==============================\n"
	    set buf [split $expect_out(buffer) "\n"]
	    set pld ""
	    set public_payload "public_payload.log"
	    set outFileId [open $public_payload "w"]
	    for {set idx 0} {$idx<100} {incr idx} {
		set pubpl [lindex $buf $idx]
		if {[string match "*list*" $pubpl]} {
		    break
		}
		if {[string match "*$ring_name*" $pubpl]} {
		    break
		}
		append pld '\n $pubpl
		puts $outFileId "$pubpl"
	    }
	    close $outFileId

	    spawn $ringcrypto -def public_payload.log
	    expect {
		":dec" {
		    puts "Payload value decoded OK"
		}
		"Error" {
		    puts "Decoding Error!!!!!!!!!!!!!!!!!!!!!!!\n"
		}
	    }
	    # always restore spawn id after using $ringcrypto
	    set spawn_id $blueID
	}
	puts "\n"
	if { $debug != "debug" } {
	    if { $name == "GET_WIFI_STATUS" } {
		log_user 0
	    }
	}
    } elseif { $command == "N"}    {
	send "select-attribute $url\r"
	send "notify on\r"
	expect "Value:"
	#send "notify off\r"
	puts "\n"
    } else {
	puts "command \"$command\" ignored, continue...\n"
	continue
    }
}
if { $debug != "debug" } {
    log_user 0
}
send "disconnect $mac\r"
expect "Connected: no"
send "quit\r"
close


