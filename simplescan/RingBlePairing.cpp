/*---------------------------------------------------------------------
 *               ------------------      -----------------            *
 *               | Ring App Setup |      |   test_ble    |            *
 *               ------------------      -----------------            *
 *                          |                |                        *
 *                          |   --------------------                  *
 *                          |   |gatt_src_test.cpp |                  *
 *                          |   --------------------                  *
 *                          |     |          |                        *
 *              ----------------------       |                        *
 *              | RingBlePairing.cpp |       |                        *
 *              ----------------------       |                        *
 *                          |                |                        *
 *                  ---------------------------------                 *
 *                  |    RinmBleApi.cpp abstract    |                 *
 *                  ---------------------------------                 *
 *                  |  RingGattSrv  |  RingGattSrv  |                 *
 *                  |   WILINK18    |    BCM43      |                 *
 *                  --------------------------------                  *
 *                        |                  |                        *
 *       ------------------------       ---------------               *
 *       |      TIBT lib        |       |   BlueZ     |               *
 *       ------------------------       ---------------               *
 *                  |                        |                        *
 *       ------------------------       ----------------              *
 *       | TI WiLink18xx BlueTP |       | libbluetooth |              *
 *       ------------------------       ----------------              *
 *--------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>

#include "Bot_Notifier.h"
#include "RingBleApi.hh"
#include "RingGattApi.hh"
#include "RingBlePairing.hh"

#include "gatt_svc_defs.h"

using namespace Ring;
using namespace Ring::Ble;

/* -------------------------------------------------------------*
 * section of auto-declaration
 * the define file may be included multiple times to generate
 * different stuctures correlated by order of definition
 * -------------------------------------------------------------*/
#define RING_PAIRING_TABLE_SERVICE_DECL
#include "gatt_svc_defs.h"

#define RING_PAIRING_TABLE_SERVICE_DEFINE_TABLE
static AttributeInfo_t SrvTable0[] = {
    #include "gatt_svc_defs.h"
};

#define RING_PAIRING_TABLE_ATTR_ENUM
enum GattAttributeIndexByName {
    #include "gatt_svc_defs.h"
    RING_PAIRING_TABLE_ATTR_MAX
};
// compiler time check for characteristics max
#if !(RING_CHARACTERISTICS_MAX > RING_PAIRING_TABLE_ATTR_MAX)
#error "RING_CHARACTERISTICS_MAX > RING_PAIRING_TABLE_ATTR_MAX"
#endif

#define RING_PAIRING_SERVICE_INFO_DEFINE
#include "gatt_svc_defs.h"

/* -------------------------------------------------------------*
 * static callback function declaration
 * -------------------------------------------------------------*/
static void OnAttributeAccessCallback(int aServiceIdx, int aAttributeIdx, Ble::Property::Access aAccessType);
std::function<int(int, void*, int)> ringDataCb = NULL;

/* -------------------------------------------------------------*
 * BlePairing class implementation
 * -------------------------------------------------------------*/
BlePairing* BlePairing::instance = NULL;
const char* BlePairing::mPayloadReady = "PAYLOAD_READY";
const char* BlePairing::mWiFiConnected = "WIFI_CONNECTED";
const char* BlePairing::mWiFiConnectFailed = "WIFI_CONNECT_FAILED";
const char* BlePairing::mWiFiConfigFile = "/ring/wifi.conf";

char BlePairing::mMacAddress[DEV_MAC_ADDR_LEN] = "XX:XX:XX:XX:XX:XX";
char BlePairing::mNetworkInfo[ATT_MTU_MAX] = "";
char BlePairing::mPublicPayload[ATT_MTU_MAX] = "placeholder for public payload generated by GATT server";

#define ATTRIBUTE_OFFSET(_idx) sServiceTable[RING_PAIRING_SVC_IDX].AttributeList[_idx].AttributeOffset
#define SET_ATTRIBUTE_STR_VAL(_value) (Byte_t *) _value, strlen(_value)

// singleton instance
BlePairing* BlePairing::getInstance() {
    if (instance == NULL)
        instance = new BlePairing();
    return instance;
}

// private constructor
BlePairing::BlePairing() :
    mPairingServiceIndex(0),
    mAdvertisingRequested(false)
{
    if (NULL == (mBleApi = GattSrv::getInstance()))
    {
        BOT_NOTIFY_INFO("BlePairing failed to obtain BleApi instance");
    }

    // set other config parameters
    mLocalClassOfDevice = 0x280430;
    mAdvertisingTimeout_sec = 600;
    mAdvIntervalMin_ms = 2000;
    mAdvIntervalMax_ms = 3000;

    // set definitions from RingGattServices.hh
    mServiceTable = sServiceTable;
    mServiceCount = RING_GATT_SERVICES_COUNT;

    // initialize with default string, ringnm will set proper device name later
    strncpy(mRingDeviceName, "RingSetup-BT", DEV_NAME_LEN);
}

///
/// \brief BlePairing::Initialize
/// \return Ble::Error
///
int BlePairing::Initialize(char *aDeviceName, uint8_t * mac)
{
    int ret_val = Error::UNDEFINED;

    // BLE Device Configuration
    if (aDeviceName != NULL)
    {
        // override device name
        strncpy(mRingDeviceName, aDeviceName, DEV_NAME_LEN);
    }

    if (mac != NULL)
    {
        AttributeInfo_t *attribute_list = mServiceTable[RING_PAIRING_SVC_IDX].AttributeList;
        sprintf(mMacAddress, "%02X:%02X:%02X:%02X:%02X:%02X",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        ((CharacteristicInfo_t*) (attribute_list[GET_MAC_ADDRESS].Attribute))->Value = (Byte_t*) mMacAddress;
        ((CharacteristicInfo_t*) (attribute_list[GET_MAC_ADDRESS].Attribute))->ValueLength = strlen(mMacAddress);
    }

    DeviceConfig_t config[] =
    { // config tag                         count   params
        {Ble::Config::ServiceTable,           {1,   {{(char*) mServiceTable, mServiceCount}}}},
        {Ble::Config::LocalDeviceName,        {1,   {{(char*) mRingDeviceName, Ble::ConfigArgument::None}}}},
        {Ble::Config::LocalClassOfDevice,     {1,   {{NULL, mLocalClassOfDevice}}}},
        {Ble::Config::Discoverable,           {1,   {{NULL, Ble::ConfigArgument::Enable}}}},
        {Ble::Config::Connectable,            {1,   {{NULL, Ble::ConfigArgument::Enable}}}},
        {Ble::Config::Pairable,               {1,   {{NULL, Ble::ConfigArgument::Enable}}}},
        {Ble::Config::LocalDeviceAppearance,  {1,   {{NULL, BleApi::BLE_APPEARANCE_GENERIC_COMPUTER}}}},
        {Ble::Config::AdvertisingInterval,    {2,   {{NULL, mAdvIntervalMin_ms}, {NULL, mAdvIntervalMax_ms}}}},
        {Ble::Config::RegisterGATTCallback,   {0,   {{NULL, Ble::ConfigArgument::None}}}},
        {Ble::Config::RegisterService,        {1,   {{NULL, mPairingServiceIndex}}}},
        {Ble::Config::RegisterAuthentication, {0,   {{NULL, Ble::ConfigArgument::None}}}},
        {Ble::Config::SetSimplePairing,       {2,   {{NULL, Ble::ConfigArgument::None}, {NULL, Ble::ConfigArgument::None}}}},
        {Ble::Config::EnableBluetoothDebug,   {2,   {{NULL, Ble::ConfigArgument::Enable}, {NULL, Ble::ConfigArgument::Terminal}}}},
        {Ble::Config::EOL,                    {0,   {{NULL, Ble::ConfigArgument::None}}}},
    };

    // try one more time
    if (mBleApi == NULL)
    {
        mBleApi = GattSrv::getInstance();
    }

    // if still no luck - return error
    if (mBleApi == NULL)
    {
        BOT_NOTIFY_ERROR("BlePairing failed to obtain BleApi instance");
        ret_val = Error::FAILED_INITIALIZE;
    }
    else
    {
        if (Ble::Error::NONE != (ret_val = mBleApi->Initialize()))
        {
            BOT_NOTIFY_ERROR("mBleApi->Initialize() failed.");
        }
        else if (Ble::Error::NONE != (ret_val = mBleApi->SetDevicePower(Ble::ConfigArgument::PowerOn)))
        {
            BOT_NOTIFY_ERROR("mBleApi->SetDevicePower(ON) failed.");
        }
        else if (Ble::Error::NONE != (ret_val = mBleApi->Configure(config)))
        {
            BOT_NOTIFY_ERROR("mBleApi->Configure failed, ret = %d, Abort.", ret_val);
        }
        else if (Ble::Error::NONE != (ret_val = mBleApi->RegisterCharacteristicAccessCallback(OnAttributeAccessCallback)))
        {
            BOT_NOTIFY_ERROR("mBleApi->RegisterCharacteristicAccessCallback failed, ret = %d, Abort.", ret_val);
        }
    }

    return ret_val;
}

///
/// \brief BlePairing::StartAdvertising
/// \return  Ble::Error
///
int BlePairing::StartAdvertising(int aTimeout)
{
    int ret_val = Error::UNDEFINED;

    // mAdvertisingRequested is set to true here because it is not indicator
    // of advertisement is in progress or not, but the fact the user wanted to start it
    mAdvertisingRequested = true;

    if (mBleApi == NULL)
    {
        BOT_NOTIFY_WARNING("BlePairing failed to obtain BleApi instance");
        ret_val = Error::NOT_INITIALIZED;
    }
    else
    {
        if (aTimeout > 0)
        {
            // override default mAdvertisingTimeout_sec
            mAdvertisingTimeout_sec = aTimeout;
        }

        // start advertising
        unsigned int adv_flags = Advertising::Discoverable  | Advertising::Connectable      |
                                 Advertising::AdvertiseName | Advertising::AdvertiseTxPower | Advertising::AdvertiseAppearance;
        ParameterList_t params = {2, {{NULL, adv_flags}, {NULL, mAdvertisingTimeout_sec}}};

        if (Ble::Error::NONE != (ret_val = mBleApi->StartAdvertising(&params)))
        {
            BOT_NOTIFY_ERROR("mBleApi->StartAdvertising failed, ret = %d, Abort.", ret_val);
        }
    }
    return ret_val;
}

///
/// \brief BlePairing::StopAdvertising
/// \return
///
int BlePairing::StopAdvertising()
{
    int ret_val = Error::UNDEFINED;

    // mAdvertisingRequested is set to false here because it is not indicator
    // of advertisement is in progress or not, but the fact the user wanted to stop it
    mAdvertisingRequested = false;

    if (mBleApi == NULL)
    {
        BOT_NOTIFY_WARNING("BlePairing failed to obtain BleApi instance");
        ret_val = Error::NOT_INITIALIZED;
    }
    else
    {
        ParameterList_t params = {1, {{0, 0}}};
        if (Ble::Error::NONE != (ret_val = mBleApi->StopAdvertising(&params)))
        {
            // ret_val can be != Error::NONE also if adv was not started or already expired
            BOT_NOTIFY_WARNING("mBleApi->StopAdvertising ret = %d", ret_val);
        }
    }
    return ret_val;
}

///
/// \brief BlePairing::Shutdown
/// \return
///
int BlePairing::Shutdown()
{
    int ret_val = Error::UNDEFINED;

    if (mBleApi == NULL)
    {
        BOT_NOTIFY_WARNING("BlePairing failed to obtain BleApi instance");
        ret_val = Error::NOT_INITIALIZED;
    }
    else
    {   // deactivate GATT Server
        if (mAdvertisingRequested)
            this->StopAdvertising();

        ParameterList_t null_params= {0,   {{NULL, Ble::ConfigArgument::None}}};
        ParameterList_t svc_params = {1,   {{NULL, mPairingServiceIndex}}};

        if (Ble::Error::NONE != (ret_val = mBleApi->GATTUnRegisterService(&svc_params)))
        {
            BOT_NOTIFY_ERROR("mBleApi->GATTUnRegisterService failed.");
        }
        if (Ble::Error::NONE != (ret_val = mBleApi->UnRegisterGATMEventCallback(&null_params)))
        {
            BOT_NOTIFY_ERROR("mBleApi->UnRegisterGATMEventCallback failed.");
        }
        if (Ble::Error::NONE != (ret_val = mBleApi->UnRegisterAuthentication(&null_params)))
        {
            BOT_NOTIFY_ERROR("mBleApi->UnRegisterAuthentication failed.");
        }
        if (Ble::Error::NONE != (ret_val = mBleApi->UnregisterCharacteristicAccessCallback(OnAttributeAccessCallback)))
        {
            BOT_NOTIFY_ERROR("mBleApi->UnRegisterCharacteristicAccessCallback failed.");
        }
        // TODO: do we want to power off the BLE device completely and shutdown?
        if (Ble::Error::NONE != (ret_val = mBleApi->SetDevicePower(Ble::ConfigArgument::PowerOff)))
        {
            BOT_NOTIFY_ERROR("mBleApi->SetDevicePower(OFF) failed.");
        }
        else if (Ble::Error::NONE != (ret_val = mBleApi->Shutdown()))
        {
            BOT_NOTIFY_ERROR("mBleApi->Shutdown failed.");
        }
    }
    return ret_val;
}

///
/// \brief BlePairing::Status
/// \return
///
int BlePairing::PrintStatus()
{
    int ret_val = Error::UNDEFINED;

    if (mBleApi == NULL)
    {
        BOT_NOTIFY_WARNING("BlePairing failed to obtain BleApi instance");
        ret_val = Error::NOT_INITIALIZED;
    }
    else if (Ble::Error::NONE != (ret_val = mBleApi->QueryLocalDeviceProperties(NULL)))
    {
        BOT_NOTIFY_ERROR("mBleApi->QueryLocalDeviceProperties failed.");
    }
    return ret_val;
}

///
/// \brief OnAttributeAccessCallback
/// \param aServiceIdx
/// \param aAttributeIdx
/// \param aAccessType
///
static void OnAttributeAccessCallback(int aServiceIdx, int aAttributeIdx, Ble::Property::Access aAccessType)
{
    static const unsigned int service_id = sServiceTable[RING_PAIRING_SVC_IDX].ServiceID;
    static const AttributeInfo_t *attribute_list = sServiceTable[RING_PAIRING_SVC_IDX].AttributeList;

    if (aAccessType == Ble::Property::Disconnected)
    {
        // special case to re-enable advertisement if it was susspended by connection, but
        // user didn't cancel the request to start it
        BlePairing *pairing_inst = BlePairing::getInstance();

        if (pairing_inst)
        {
            BOT_NOTIFY_DEBUG("Ble::Property::Disconnected, ads = %d, %s", pairing_inst->isAdvertisingRequested()?1:0, pairing_inst->isAdvertisingRequested()?"restarting":"");
            if (pairing_inst->isAdvertisingRequested())
            {
                pairing_inst->StartAdvertising();
            }
        }
        return;
    }

    BOT_NOTIFY_INFO("OnAttributeAccessCallback Ble::Property::%s for %s %s\n",
           aAccessType == Ble::Property::Read ? "Read": aAccessType == Ble::Property::Write ? "Write":"Confirmed",
           sServiceTable[aServiceIdx].ServiceName, sServiceTable[aServiceIdx].AttributeList[aAttributeIdx].AttributeName);

    BleApi* bleApi = GattSrv::getInstance();
    if (bleApi == NULL)
    {
        BOT_NOTIFY_ERROR("OnAttributeAccessCallback failed to obtain BleApi instance");
        return;
    }

    Ble::GATT_UUID_t uuid;
    uuid.UUID_Type     = Ble::guUUID_128;
    uuid.UUID.UUID_128 = ((CharacteristicInfo_t*) (attribute_list[aAttributeIdx].Attribute))->CharacteristicUUID;
    bleApi->DisplayGATTUUID(&uuid, "Characteristic: ", 0);

    switch (aAccessType)
    {
    case Ble::Property::Read:
        BOT_NOTIFY_DEBUG("Read");
        bleApi->DisplayAttributeValue(aServiceIdx, aAttributeIdx);
        switch (aAttributeIdx)
        {
            case GET_NET_INFO:
                BOT_NOTIFY_DEBUG("got network info");
                break;

            case GET_AP_LIST:
                BOT_NOTIFY_DEBUG("got ap list");
                break;

            default:
                break;
        }
        // ringnm callback
        if (ringDataCb)
        {
            ringDataCb(aAttributeIdx, NULL, 0);
        }
        break;
    case Ble::Property::Confirmed:
        bleApi->DisplayAttributeValue(aServiceIdx, aAttributeIdx);
        // other things todo...
        break;

    case Ble::Property::Write:
        {
            BOT_NOTIFY_DEBUG("Write");
            bleApi->DisplayAttributeValue(aServiceIdx, aAttributeIdx);

            void * pData = (void *) ((CharacteristicInfo_t*) (attribute_list[aAttributeIdx].Attribute))->Value;
            int len = ((CharacteristicInfo_t*) (attribute_list[aAttributeIdx].Attribute))->ValueLength;
            // ringnm callback
            if (ringDataCb)
            {
                ringDataCb(aAttributeIdx, pData, len);
            }

            switch (aAttributeIdx)
            {
            case SET_PUBLIC_KEY:
                /*
                       "\tOn geting PUBLIC_KEY the device generates Public/Private keys. A randomly generated nonce start\n" \
                       "\tset of 20 bytes is generated. The the device then takes the public key, and signs it using ed25519\n" \
                       "\tand a private key that is embedded in the application and creates a 64 byte signature of the ephemeral\n" \
                       "\tpublic key. The public key, signature, and nonce start are saved as the Public Payload - GET_PUBLIC_PAYLOAD.\n" \
                       "\tThe device notifies the payload ready with GET_PAIRING_STATE value PAYLOAD_READY\n\n");
               */

                bleApi->GATTUpdateCharacteristic(service_id, ATTRIBUTE_OFFSET(GET_PUBLIC_PAYLOAD), SET_ATTRIBUTE_STR_VAL(BlePairing::mPublicPayload));
                bleApi->NotifyCharacteristic(RING_PAIRING_SVC_IDX, GET_PAIRING_STATE, BlePairing::mPayloadReady);

                break;

            case SET_SECRET_KEY:
            case SET_PROVISION:
                break;

            default:
                break;
        }
        break;
    }

    default:
        break;
    }
}

int BlePairing::registerRingDataCallback(std::function<int(int, void*, int)> callback)
{
    BOT_NOTIFY_INFO("registering ring data callback");
    ringDataCb = callback;

    return Error::NONE;
}

int BlePairing::updateAttribute(int attr_idx, const char * str_data, int len)
{
    BleApi* bleApi = GattSrv::getInstance();
    if (bleApi == NULL)
    {
        BOT_NOTIFY_ERROR("updateAttribute failed to obtain BleApi instance");
        return Error::FAILED_INITIALIZE;
    }

    unsigned int service_id = sServiceTable[RING_PAIRING_SVC_IDX].ServiceID;

    // only when str_data is valid
    if (str_data)
    {
        if (len > 0)
            bleApi->GATTUpdateCharacteristic(service_id, ATTRIBUTE_OFFSET(attr_idx), (Byte_t*) str_data, len);
        else
            bleApi->GATTUpdateCharacteristic(service_id, ATTRIBUTE_OFFSET(attr_idx), SET_ATTRIBUTE_STR_VAL(str_data));
    }

    if (attr_idx == GET_NET_INFO)
    {
        bleApi->NotifyCharacteristic(RING_PAIRING_SVC_IDX, GET_PAIRING_STATE, "NETWORK_INFO_UPDATED");
    }
    else if (attr_idx == GET_AP_LIST)
    {
        bleApi->NotifyCharacteristic(RING_PAIRING_SVC_IDX, GET_PAIRING_STATE, "AP_LIST_UPDATED");
    }
    else if (attr_idx == SET_PROVISION)
    {
        bleApi->NotifyCharacteristic(RING_PAIRING_SVC_IDX, GET_PAIRING_STATE, "PROVISIONED");
    }
    else if (attr_idx == GET_WIFI_STATUS)
    {
        bleApi->NotifyCharacteristic(RING_PAIRING_SVC_IDX, GET_PAIRING_STATE, "WIFI_STATUS_UPDATED");
    }

    return Error::NONE;
}
